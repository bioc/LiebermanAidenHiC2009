%\VignetteIndexEntry{Exploration of HiC data}}
%\VignettePackage{LiebermanAidenHiC2009}

% To compile this document
% library('weaver'); rm(list=ls()); Sweave('LiebermanAidenHiC2009.Rnw', driver=weaver()); system('pdflatex LiebermanAidenHiC2009')

\documentclass{article}

\usepackage{Sweave}
\usepackage[a4paper]{geometry}
\usepackage{hyperref,graphicx}
\usepackage{cite}
\usepackage{color}
\usepackage{url}
\usepackage{listings}

\SweaveOpts{keep.source=TRUE,eps=FALSE,prefix=FALSE,include=FALSE,height=4.5,width=4} 

\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}

\newcommand{\fixme}[1]{{\textbf{Fixme:} \textit{\textcolor{blue}{#1}}}}
\newcommand{\myfig}[3]{%
  \begin{figure}[tb!]
    \begin{center}
      \includegraphics[width=#2]{#1}
      \caption{\label{#1}#3}
    \end{center}
  \end{figure}
}
\renewcommand{\floatpagefraction}{0.9}	

\title{\textsf{\textbf{Exploration of HiC data}}}
\author{Felix Klein, Wolfgang Huber}
\begin{document}
\maketitle
\begin{abstract}
\begin{enumerate}
\item Why is it important?
\item What is the problem?
\item What do we here do about it?
\item What will you learn?
\item What is the wider implication?
\end{enumerate}
\end{abstract}

\tableofcontents

%--------------------------------------------------
\section{Obtaining the data}
%--------------------------------------------------
The data associated with the article~\cite{LiebermanAiden2009} is available from NCBI Gene Expression Omnibus
under the accession GSE18199. From this record, we downloaded the supplementary file GSE18199\_RAW.tar and extracted
\begin{lstlisting}
$ wget ftp://ftp.ncbi.nih.gov/pub/geo/DATA/supplementary/\
      series/GSE18199/GSE18199_RAW.tar
$ tar -xzvf GSE18199_RAW.tar  
$ gunzip GSM455*txt.gz
\end{lstlisting}

From these, we selected six files, GSM455133 \ldots GSM455138. They
contain HiC data for the GM06990 cell line from three experiments (two
replicates with the restriction enzyme HindIII and one with NcoI). 
The sample information is summarized in the following table.

<<pData>>=
sampleAnnotation = 
  data.frame(
    file = c("GSM455133_30E0LAAXX.1.maq.hic.summary.binned.txt",
             "GSM455134_30E0LAAXX.2.maq.hic.summary.binned.txt",
             "GSM455135_30U85AAXX.2.maq.hic.summary.binned.txt",
             "GSM455136_30U85AAXX.3.maq.hic.summary.binned.txt",
             "GSM455137_30305AAXX.1.maq.hic.summary.binned.txt",
             "GSM455138_30305AAXX.2.maq.hic.summary.binned.txt"),
    restrictionenzyme = c("HindIII", "HindIII", "HindIII", "HindIII",
                          "NcoI", "NcoI"),
    replicate = c(1,2,1,2,1,2),
    otherFactor = rep(NA, 6),
    stringsAsFactors = FALSE)
@ 
\fixme{Fix the table: currently, column \Robject{restrictionenzyme} is wrong/random,
       and add any other pertinent sample information.}

The format of these files is explained in the file
\texttt{GSE18199\_readme\_v4.txt}, which we provide in the
\texttt{extdata} directory of the package.
Briefly, each line corresponds to one paired end alignment.
Each line has 9 entries:
\begin{center}
\texttt{read name, chromosome1, position1, strand1, restrictionfragment1, chromosome2, position2, strand2, restrictionfragment2}
\end{center}
Of these,  the four with last character "1" correspond to the first paired end, and the four with last character "2" to the second paired end. \texttt{position} is position in base pairs where the alignment starts. The alignments are based on the hg18 assembly of the human genome.

Altogether, these files encompass ca.~8.4 Mio lines. Here we will only focus on chromosome 14.

We used the following code to select only those lines that correspond to read pairs for 
which both ends aligned to chromosome 14, and to create the dataframe \Robject{HiC_GM_chr14}, which
is provided in the package. 
% , eval=FALSE>>=
<<readtable>>=  
inputDir = system.file("extdata", package="LiebermannAidenHiC2009.Rnw")
inputDir = "/g/huber/course"
inputDir = "/Users/huber/LiebermanAiden"
df = vector(mode="list", length=nrow(sampleAnnotation))
for(i in seq(along=df)) {
  cat("Reading file", i, "\n")
  r = read.table(file.path(inputDir, sampleAnnotation$file[i]), 
           header=FALSE, sep="\t", comment.char = "", stringsAsFactors=FALSE)
  colnames(r) = c("read name",
     "chromosome1", "position1", "strand1", "restrictionfragment1",
     "chromosome2", "position2", "strand2", "restrictionfragment2")
  df[[i]] = subset(r, (chromosome1==14L) & (chromosome2==14L))
}
HiC_GM_chr14 = do.call(rbind, df)
save(HiC_GM_chr14,
     file.path("..", "extdata", "HiC_GM_chr14.RData"))
@ 
\fixme{Move the files into the package, rather than /g/huber/course}
  
%---------------------------------------------------------
\section{The adjacency matrix for chromosome 14}
%---------------------------------------------------------
We load the data and look at the scatterplot for start and end positions (Figure~\ref{figscatter}).

<<data>>=
# data("HiC_GM_chr14_all.RData")    # can use this once the data set is in the package
load(file.path("..", "extdata", "HiC_GM_chr14_all.RData"))
pos = with(HiC_GM_chr14, cbind(position1, position2))
@ 
<<figscatter,fig=TRUE>>=
plot(pos,pch='.')
@

\incfig{figscatter}{0.5\textwidth}{%
Scatterplot of positions 1 and 2 for the HiC read pairs for which both ends map to chromosome 14.
}

To create a matrix of intrachromosomal locus--locus interaction frequencies, let us smooth the data.

<<smooth, cache=TRUE, results=hide>>=
library("KernSmooth")
chrlen = max(pos)
gridsize = ceiling(chrlen/3e5)
den = bkde2D( pos, bandwidth=c(1,1)*3e5, gridsize=c(1,1)*gridsize)
@ 

Since the the labeling of the reads within a pair as 1 or 2 is arbitrary, and since 
pairwise interaction is a symmetric concept, we symmetrize the matrix.
<<symm, cache=TRUE>>=
den$fhat <- den$fhat + t(den$fhat)
@ 

Let us use the \Rfunction{image} function to visualise the interaction matrix in false color representation.
%
<<figmatrix,fig=TRUE,width=7,height=7>>=
with(den, image(x=x1, y=x2, z=fhat^0.3, 
      col=colorRampPalette(c("white","blue"))(256), useRaster=TRUE))
@ 
The result is shown in Figure~\ref{figmatrix}.
\begin{itemize}
\item What is the point of the exponentiation (\Robject{^0.3})? What happens if you do not do it, or use another 
function?
\end{itemize}

\myfig{figmatrix}{0.75\textwidth}{%
  Adjacency matrix obtained from smoothing the positions of paired read alignments.
  Compare this to Figure\fixme{?} in the paper~\cite{LiebermanAiden2009}.}

The diagonal is strongly pronounced because the contact frequency is highest for small genomic distances. To normalize for this, and focus on the (possibly interesting) deviations from this general relationship, we calculate the mean number of interactions at a given genomic distance. First we do this for the secondary diagonals and make the matrix symmetric. After this we add the diagonal.  

<<normalize, cache=TRUE>>=
m = matrix(0, nrow=gridsize, ncol=gridsize)
for(i in 1:(gridsize-1)) {
  band = (row(m)==col(m)+i)
  m[band] = mean(den$fhat[band])
}
m = m + t(m)
diag(m) = mean(diag(den$fhat))
@

With the calculated matrix of average interactions we can normalize our data by deviding the two matrices and plot the result.

<<normalize2, eval=FALSE>>=
normDen <- den
normDen$fhat <- normDen$fhat/m

with(normDen, image(x=x1,y=x2,z=fhat, col=colorRampPalette(c("white","blue"))(256), useRaster=TRUE))
@

Now the plaid pattern is more pronounced than before. However it can still be improved by caluclating the correlation matrix, where the entry (i,j) is the correlation of the of the rowvector i with coloumvector j. Using a third color in the plot, we can see that the chromosome basically splits into 2 compartments.

<<cormatrix, eval=FALSE>>=
cm <- cor(normDen$fhat)

corDen <- normDen
corDen$fhat <- cm

with(corDen, image(x=x1,y=x2,z=fhat, col=colorRampPalette(c("red", "white","blue"))(256), useRaster=TRUE))
@

As next step we perform a principal component analysis on the matrix and retrieve the first two eigenvectors. Because we want to compare these vectors to chip-seq experiments of histone modifications and DNAse1 sensitivity, we use run-length encoding (rle) to store the vectors. \fixme{Efficient way of storing data that is constant over long ranges.}  

<<cormatrix, eval=FALSE>>=
princp = princomp(corDen$fhat)
plot(princp$loadings[,1])

pc1Vec = Rle(values  = princp$loadings[,1],
             lengths = c(normDen$x1[1], diff(normDen$x1)))
pc2Vec = Rle(values  = princp$loadings[,2],
             lengths = c(normDen$x1[1], diff(normDen$x1)))
@

To compare with the chip-seq data we have to load the files and store them as rle vectors. The data files contain the the following information about chip-seq peaks:
\begin{center}
\texttt{chromosome, start position, end position, name, score, strand, signal value, pValue, qValue}
\end{center}
We are only interesstend in data of chromosome 14 and want the start position, end position and the signal value in this range. To create the rle vectors we use the following function.

<<readchipseq, eval=FALSE>>=
createRleVector = function(file){
  tab = read.table(gzfile(file), header=FALSE, sep="\t", comment.char = "", stringsAsFactors=FALSE)
  colnames(tab) <- c("chr", "start", "end", "name", "score", "strand", "signalValue", "pValue", "qValue")
  ## filter chromosom 14
  tab = tab[tab$chr == "chr14",]  
  RleVec = Rle(0, max(tab$end))
  for(i in 1:nrow(tab)){
    RleVec = RleVec + 
                  Rle(values  = c(0, tab$signalValue[i], 0),
                    lengths = c( tab$start[i]-1, tab$end[i]-tab$start[i]+1,   length(RleVec)-tab$end[i]))
  }
    
  RleVec
}

files = paste("/g/huber/course", c("wgEncodeBroadHistoneGm12878H3k27me3StdPk.broadPeak.gz", 
                                    "wgEncodeBroadHistoneGm12878H3k36me3StdPk.broadPeak.gz",
                                    "wgEncodeUwDnaseGm06990HotspotsRep1.broadPeak.gz",
                                    "wgEncodeUwDnaseGm06990HotspotsRep2.broadPeak.gz"), sep="/")

H3k27me3 = createRleVector(files[1])
H3k36me3 = createRleVector(files[2])

Dnase1 = createRleVector(files[3])
Dnase2 = createRleVector(files[4])
@

To combine the two DNAse1 replicates we have to make sure that the vectors have the same length. 

<<combinednase, eval=FALSE>>=
length(Dnase1)
length(Dnase2)

Dnase = Dnase1[seq(along=Dnase2)] + Dnase2
@

For plotting the first Eigenvector against the chip-seq data, we have to make sure that we use the same scale for all plots. Therefore we define a plotting function that covers the same genomic range by setting a fixed xlim. We also want to plot them on top of each other in one plot and do this by setting par accordingly.

<<plotvectors, eval=FALSE>>=
plotRle = function(RleVector, ...){
  plot(end(RleVector), runValue(RleVector)+1, type="h", log="y", xlim = c(1.5e+7, 107000000), ...)
}

par(mfrow=c(4,1))

plotRle(pc1Vec)
plotRle(H3k27me3)
plotRle(H3k36me3)
plotRle(Dnase1)
@

From looking at the plots the data seems to correlate quite good. However to quantify this we have to calculate the correlation of the vectors. To do this we have to make sure that they are of the same length.

<<correlation, eval=FALSE>>=
length(H3k27me3)
length(H3k36me3)
length(Dnase)
length(pc1Vec)

x <- seq(along=H3k36me3)

cor(H3k27me3[x], pc1Vec[x])
cor(H3k36me3, pc1Vec[x])
cor(Dnase[x], pc1Vec[x])
@

As you the the correlation coefficents are less convincing as the visual impression, especially for the DNAse1. 
If you have time left, you can dicuss this topic or repeat the last steps for the second eigenvector of the principal component analysis.

%---------------------------------------------------------
% SessionInfo
%---------------------------------------------------------
\begin{table*}[tbp]
\begin{minipage}{\textwidth}
<<sessionInfo, results=tex, print=TRUE>>=
toLatex(sessionInfo())
@ 
\end{minipage}
\caption{\label{tab:sessioninfo}%
The output of \Rfunction{sessionInfo} on the build system 
after running this vignette.}
\end{table*}



%--------------------------------------------------
\bibliography{LiebermanAidenHiC2009}
\bibliographystyle{plain}
\end{document}
